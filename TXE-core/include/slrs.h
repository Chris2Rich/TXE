#ifndef _CSLRS_H
#define _CSLRS_H

#include <vector>
#include <string>
#include <stdexcept>
#include <iostream> // For debugging, remove later

// RELIC
#if defined(ALLOC_AUTO)
#error "RELIC memory allocation mode is not compatible with this code. Use ALLOC_STACK or ALLOC_DYNAMIC."
#endif

extern "C" {
#include <relic/relic.h>
}

// Helper libraries (ensure these are in your include path)
#include "util.h"    // For uchar_to_hex, etc.
#include "sha512.h"  // For hash512

// --- Structures for Parameters, Keys, and Signatures ---

struct SLRS_SystemParameters {
    ec_t P;         // Generator of G1
    ec_t P_pub;     // sP (where s is a system secret, not explicitly stored here if not needed beyond P_pub)
    ec_t G1_const;  // Public G1 element G1 from paper
    ec_t G2_const;  // Public G1 element G2 from paper (relic G1 type)
    ec_t K_const;   // Public G1 element K from paper
    ec_t Q_const;   // Public G1 element Q from paper
    ec_t Q_pub;     // s_m * Q_const (TTP's public key component)
    ec_t V_ring_pubkey; // Ring public key V = g(f(u,X)), an ec_t point.
                       // For this scheme, W in user's key is also this V.

    SLRS_SystemParameters() {
        ec_null(P); ec_new(P);
        ec_null(P_pub); ec_new(P_pub);
        ec_null(G1_const); ec_new(G1_const);
        ec_null(G2_const); ec_new(G2_const);
        ec_null(K_const); ec_new(K_const);
        ec_null(Q_const); ec_new(Q_const);
        ec_null(Q_pub); ec_new(Q_pub);
        ec_null(V_ring_pubkey); ec_new(V_ring_pubkey);
    }

    ~SLRS_SystemParameters() {
        ec_free(P);
        ec_free(P_pub);
        ec_free(G1_const);
        ec_free(G2_const);
        ec_free(K_const);
        ec_free(Q_const);
        ec_free(Q_pub);
        ec_free(V_ring_pubkey);
    }
};

struct SLRS_MasterSecretKey {
    bn_t s_m; // TTP's master secret key

    SLRS_MasterSecretKey() {
        bn_null(s_m); bn_new(s_m);
    }
    ~SLRS_MasterSecretKey() {
        bn_free(s_m);
    }
};

struct SLRS_UserSecretKeyPart { // R_id, specific to a user, generated by TTP
    ec_t R_id_point;
    // std::string user_id_str; // For context if needed, not cryptographically part of R_id itself
    // bn_t h_id_scalar;       // H1(user_id_str)

    SLRS_UserSecretKeyPart() {
        ec_null(R_id_point); ec_new(R_id_point);
        // bn_null(h_id_scalar); bn_new(h_id_scalar);
    }
    ~SLRS_UserSecretKeyPart() {
        ec_free(R_id_point);
        // bn_free(h_id_scalar);
    }
};

struct SLRS_UserRingPrivateKey { // User's key for signing within a ring
    bn_t h_id_scalar;       // H1(user_id)
    ec_t R_id_point;        // User's secret key part from TTP
    ec_t W_point;           // Witness, for this scheme W = V_ring_pubkey

    SLRS_UserRingPrivateKey() {
        bn_null(h_id_scalar); bn_new(h_id_scalar);
        ec_null(R_id_point); ec_new(R_id_point);
        ec_null(W_point); ec_new(W_point);
    }
    ~SLRS_UserRingPrivateKey() {
        bn_free(h_id_scalar);
        ec_free(R_id_point);
        ec_free(W_point);
    }
};

struct SLRS_Signature {
    std::vector<unsigned char> m_message; // Serialized message
    bn_t c_scalar;
    ec_t U1_point, U2_point, R_point, T1_point, T2_point;
    ec_t L1_point, L2_point, L_link_tag_point;
    gt_t Pi1_elem, Pi2_elem;
    bn_t s_scalars[7]; // s1 to s7

    SLRS_Signature() {
        bn_null(c_scalar); bn_new(c_scalar);
        ec_null(U1_point); ec_new(U1_point);
        ec_null(U2_point); ec_new(U2_point);
        ec_null(R_point); ec_new(R_point);
        ec_null(T1_point); ec_new(T1_point);
        ec_null(T2_point); ec_new(T2_point);
        ec_null(L1_point); ec_new(L1_point);
        ec_null(L2_point); ec_new(L2_point);
        ec_null(L_link_tag_point); ec_new(L_link_tag_point);
        gt_null(Pi1_elem); gt_new(Pi1_elem);
        gt_null(Pi2_elem); gt_new(Pi2_elem);
        for (int i = 0; i < 7; ++i) {
            bn_null(s_scalars[i]); bn_new(s_scalars[i]);
        }
    }

    ~SLRS_Signature() {
        bn_free(c_scalar);
        ec_free(U1_point); ec_free(U2_point); ec_free(R_point);
        ec_free(T1_point); ec_free(T2_point);
        ec_free(L1_point); ec_free(L2_point); ec_free(L_link_tag_point);
        gt_free(Pi1_elem); gt_free(Pi2_elem);
        for (int i = 0; i < 7; ++i) {
            bn_free(s_scalars[i]);
        }
    }
};

// --- Helper: Hash function H1: {0,1}* -> Z_p ---
// Takes a vector of byte vectors, concatenates them, hashes, and maps to bn_t mod order.
bn_t H1_func(const std::vector<std::vector<unsigned char>>& parts) {
    bn_t order, result_bn;
    bn_null(order); bn_new(order);
    bn_null(result_bn); bn_new(result_bn);
    ec_curve_get_ord(order);

    std::vector<unsigned char> concatenated_input;
    size_t total_size = 0;
    for (const auto& part : parts) {
        total_size += part.size();
    }
    concatenated_input.reserve(total_size);
    for (const auto& part : parts) {
        concatenated_input.insert(concatenated_input.end(), part.begin(), part.end());
    }

    std::vector<unsigned char> hash_output = hash512(concatenated_input); // From sha512.h

    bn_read_bin(result_bn, hash_output.data(), hash_output.size());
    bn_mod(result_bn, result_bn, order);

    bn_free(order);
    return result_bn; // Remember to bn_free this where it's used or assign to a managed bn_t
}

// Helper to serialize ec_t to vector<unsigned char>
std::vector<unsigned char> ec_point_to_bytes(const ec_t p) {
    int len = ec_size_bin(p, 1); // 1 for compressed
    std::vector<unsigned char> buf(len);
    ec_write_bin(buf.data(), len, p, 1);
    return buf;
}

// Helper to serialize bn_t to vector<unsigned char>
std::vector<unsigned char> bn_scalar_to_bytes(const bn_t n) {
    int len = bn_size_bin(n);
    std::vector<unsigned char> buf(len);
    bn_write_bin(buf.data(), len, n);
    return buf;
}

// Helper to serialize gt_t to vector<unsigned char>
std::vector<unsigned char> gt_elem_to_bytes(const gt_t g) {
    int len = gt_size_bin(g, 1); // 1 for compressed
    std::vector<unsigned char> buf(len);
    gt_write_bin(buf.data(), len, g, 1);
    return buf;
}


// --- Core Algorithm Implementations ---

// 2.2.1 System Setup Algorithm (SET-BP)
void setup(SLRS_SystemParameters& params, SLRS_MasterSecretKey& msk) {
    bn_t s, order;
    bn_null(s); bn_new(s);
    bn_null(order); bn_new(order);
    ec_curve_get_ord(order);

    // 1. Get generator P for G1
    g1_get_gen(params.P);

    // 2. Generate random s in Z_p*
    bn_rand_mod(s, order);
    ec_mul_gen(params.P_pub, s); // P_pub = sP (paper uses P_pub = sP for the 't' parameter component)

    // 3. Generate random G1_const, G2_const, K_const, Q_const in G1*
    ec_rand(params.G1_const);
    ec_rand(params.G2_const);
    ec_rand(params.K_const);
    ec_rand(params.Q_const);

    // 4. Generate master secret s_m in Z_p* and Q_pub = s_m * Q_const
    bn_rand_mod(msk.s_m, order);
    ec_mul(params.Q_pub, params.Q_const, msk.s_m);

    // 5. V_ring_pubkey (Example: just a random point for now, real setup needs accumulator logic)
    // In a real system, V_ring_pubkey would be derived from the ring members' identities.
    // For testing, we can set it to a known or random point.
    // Let's make it a distinct random point for this example.
    ec_rand(params.V_ring_pubkey);


    bn_free(s);
    bn_free(order);
}

// 2.2.2 User Private Key Generation Algorithm (KG-BP)
// Generates R_id for a given user_id string
SLRS_UserSecretKeyPart kg_bp(const SLRS_SystemParameters& params, const SLRS_MasterSecretKey& msk, const std::string& user_id_str) {
    SLRS_UserSecretKeyPart user_sk_part;
    bn_t h_id, temp_sum, inv_sum, order;

    bn_null(h_id); bn_new(h_id);
    bn_null(temp_sum); bn_new(temp_sum);
    bn_null(inv_sum); bn_new(inv_sum);
    bn_null(order); bn_new(order);
    ec_curve_get_ord(order);

    // H1(id)
    std::vector<unsigned char> id_bytes(user_id_str.begin(), user_id_str.end());
    bn_copy(h_id, H1_func({{id_bytes}})); // H1_func returns a new bn_t, copy its value
                                          // and H1_func's result should be freed if not captured.
                                          // Let's assume H1_func returns a managed bn_t that we must free.
    bn_t h_id_from_func = H1_func({{id_bytes}});
    bn_copy(h_id, h_id_from_func);
    bn_free(h_id_from_func);


    // (H1(id) + s_m)
    bn_add(temp_sum, h_id, msk.s_m);
    bn_mod(temp_sum, temp_sum, order);

    // (H1(id) + s_m)^-1 mod order
    bn_mod_inv(inv_sum, temp_sum, order);

    // R_id = (H1(id) + s_m)^-1 * Q_const
    ec_mul(user_sk_part.R_id_point, params.Q_const, inv_sum);

    // Store h_id and user_id_str for context if creating a fuller user object
    // bn_copy(user_sk_part.h_id_scalar, h_id);
    // user_sk_part.user_id_str = user_id_str;

    bn_free(h_id);
    bn_free(temp_sum);
    bn_free(inv_sum);
    bn_free(order);

    return user_sk_part;
}

// 2.2.3 Ring Public Key Generation (GPK-BP) -> V_ring_pubkey
// As discussed, V_ring_pubkey is part of SLRS_SystemParameters and assumed to be set up.
// This function would normally compute V based on a set of identities if accumulator was detailed.

// 2.2.4 Ring Private Key Generation (GSK-BP)
// Creates the key user needs to sign, from their R_id and the system's V.
SLRS_UserRingPrivateKey gsk_bp(const SLRS_SystemParameters& params, const SLRS_UserSecretKeyPart& user_sk_part, const std::string& user_id_str) {
    SLRS_UserRingPrivateKey ring_priv_key;

    // h_id = H1(id_i)
    std::vector<unsigned char> id_bytes(user_id_str.begin(), user_id_str.end());
    bn_t h_id_from_func = H1_func({{id_bytes}});
    bn_copy(ring_priv_key.h_id_scalar, h_id_from_func);
    bn_free(h_id_from_func);


    // R_id_i (already computed in user_sk_part)
    ec_copy(ring_priv_key.R_id_point, user_sk_part.R_id_point);

    // W = V_ring_pubkey (as per paper page 3 for this scheme)
    ec_copy(ring_priv_key.W_point, params.V_ring_pubkey);

    return ring_priv_key;
}


// 2.2.5 Ring Signature Algorithm (SIG-BP)
SLRS_Signature sig_bp(const SLRS_SystemParameters& params, const SLRS_UserRingPrivateKey& usk, const std::string& message_str) {
    SLRS_Signature sig;
    sig.m_message = std::vector<unsigned char>(message_str.begin(), message_str.end());

    bn_t r1, r2, r3, k1, k2, k3, k4, k5, k6, k7, a1, a2, order;
    bn_t temp_bn1, temp_bn2, temp_bn3;

    bn_null(r1); bn_new(r1); bn_null(r2); bn_new(r2); bn_null(r3); bn_new(r3);
    bn_null(k1); bn_new(k1); bn_null(k2); bn_new(k2); bn_null(k3); bn_new(k3);
    bn_null(k4); bn_new(k4); bn_null(k5); bn_new(k5); bn_null(k6); bn_new(k6); bn_null(k7); bn_new(k7);
    bn_null(a1); bn_new(a1); bn_null(a2); bn_new(a2);
    bn_null(order); bn_new(order);
    bn_null(temp_bn1); bn_new(temp_bn1); bn_null(temp_bn2); bn_new(temp_bn2); bn_null(temp_bn3); bn_new(temp_bn3);

    ec_curve_get_ord(order);

    // Random scalars r_i, k_i, a_i in Z_p
    bn_rand_mod(r1, order); bn_rand_mod(r2, order); bn_rand_mod(r3, order);
    bn_rand_mod(k1, order); bn_rand_mod(k2, order); bn_rand_mod(k3, order);
    bn_rand_mod(k4, order); bn_rand_mod(k5, order); bn_rand_mod(k6, order); bn_rand_mod(k7, order);
    bn_rand_mod(a1, order); bn_rand_mod(a2, order);

    // L = h_id_i * P (Link Tag)
    ec_mul(sig.L_link_tag_point, params.P, usk.h_id_scalar);

    // L1 = R_id_i + r1 * Q_pub
    ec_t temp_ec1; ec_null(temp_ec1); ec_new(temp_ec1);
    ec_mul(temp_ec1, params.Q_pub, r1);
    ec_add(sig.L1_point, usk.R_id_point, temp_ec1);

    // L2 = r1 * Q_const
    ec_mul(sig.L2_point, params.Q_const, r1);

    // U1 = R_id_i + r1 * K_const
    ec_mul(temp_ec1, params.K_const, r1);
    ec_add(sig.U1_point, usk.R_id_point, temp_ec1);

    // U2 = W + r2 * K_const (W is usk.W_point)
    ec_mul(temp_ec1, params.K_const, r2);
    ec_add(sig.U2_point, usk.W_point, temp_ec1);

    // R = G1_const + r2 * G2_const + r3 * K_const
    ec_t term_r2_G2, term_r3_K;
    ec_null(term_r2_G2); ec_new(term_r2_G2);
    ec_null(term_r3_K); ec_new(term_r3_K);
    ec_mul(term_r2_G2, params.G2_const, r2);
    ec_mul(term_r3_K, params.K_const, r3);
    ec_add(sig.R_point, params.G1_const, term_r2_G2);
    ec_add(sig.R_point, sig.R_point, term_r3_K);
    ec_free(term_r2_G2); ec_free(term_r3_K);

    // T1 = k4*G1_const + k5*G2_const + k6*K_const - k7*R
    ec_t k4G1, k5G2, k6K, k7R;
    ec_null(k4G1); ec_new(k4G1); ec_null(k5G2); ec_new(k5G2);
    ec_null(k6K); ec_new(k6K); ec_null(k7R); ec_new(k7R);
    ec_mul(k4G1, params.G1_const, k4);
    ec_mul(k5G2, params.G2_const, k5);
    ec_mul(k6K, params.K_const, k6);
    ec_mul(k7R, sig.R_point, k7);
    ec_add(sig.T1_point, k4G1, k5G2);
    ec_add(sig.T1_point, sig.T1_point, k6K);
    ec_sub(sig.T1_point, sig.T1_point, k7R);
    ec_free(k4G1); ec_free(k5G2); ec_free(k6K); ec_free(k7R);

    // Π1 = e(Q_const, U1)^(-k1) * e(L2, K_const)^(k4) * e(Q_pub, K_const)^(k5) * e(L+P_pub, W)
    // Using paper's k-indices (k1, k4, k5). W is usk.W_point.
    gt_t pi1_t1, pi1_t2, pi1_t3, pi1_t4;
    gt_null(pi1_t1); gt_new(pi1_t1); gt_null(pi1_t2); gt_new(pi1_t2);
    gt_null(pi1_t3); gt_new(pi1_t3); gt_null(pi1_t4); gt_new(pi1_t4);
    ec_t L_plus_Ppub; ec_null(L_plus_Ppub); ec_new(L_plus_Ppub);
    ec_add(L_plus_Ppub, sig.L_link_tag_point, params.P_pub);

    bn_t neg_k1; bn_null(neg_k1); bn_new(neg_k1);
    bn_neg(neg_k1, k1); // Compute -k1, then mod order if needed, but pairing takes full bn_t.
                        // RELIC's pc_map_exp takes bn_t, handles negative via inverse.

    pc_map_exp(pi1_t1, params.Q_const, sig.U1_point, neg_k1); // e(Q,U1)^(-k1)
    pc_map_exp(pi1_t2, sig.L2_point, params.K_const, k4);    // e(L2,K)^(k4)
    pc_map_exp(pi1_t3, params.Q_pub, params.K_const, k5);   // e(Q_pub,K)^(k5)
    pc_map(pi1_t4, L_plus_Ppub, usk.W_point);                // e(L+P_pub, W)

    gt_mul(sig.Pi1_elem, pi1_t1, pi1_t2);
    gt_mul(sig.Pi1_elem, sig.Pi1_elem, pi1_t3);
    gt_mul(sig.Pi1_elem, sig.Pi1_elem, pi1_t4);

    gt_free(pi1_t1); gt_free(pi1_t2); gt_free(pi1_t3); gt_free(pi1_t4);
    ec_free(L_plus_Ppub); bn_free(neg_k1);

    // Term for hash c: X_c = e((P_pub + a1*P) * (a2+r2)^(-1), R_id_i)
    gt_t X_c_for_hash; gt_null(X_c_for_hash); gt_new(X_c_for_hash);
    ec_t Ppub_plus_a1P, Y_pt;
    ec_null(Ppub_plus_a1P); ec_new(Ppub_plus_a1P);
    ec_null(Y_pt); ec_new(Y_pt);
    bn_t a2_plus_r2, inv_a2_plus_r2;
    bn_null(a2_plus_r2); bn_new(a2_plus_r2);
    bn_null(inv_a2_plus_r2); bn_new(inv_a2_plus_r2);

    ec_mul(temp_ec1, params.P, a1);
    ec_add(Ppub_plus_a1P, params.P_pub, temp_ec1);

    bn_add(a2_plus_r2, a2, r2);
    bn_mod(a2_plus_r2, a2_plus_r2, order);
    bn_mod_inv(inv_a2_plus_r2, a2_plus_r2, order);

    ec_mul(Y_pt, Ppub_plus_a1P, inv_a2_plus_r2);
    pc_map(X_c_for_hash, Y_pt, usk.R_id_point);

    ec_free(Ppub_plus_a1P); ec_free(Y_pt);
    bn_free(a2_plus_r2); bn_free(inv_a2_plus_r2);


    // c = H1(m || V || L || L1 || L2 || T1 || Π1 || X_c_for_hash)
    // V is params.V_ring_pubkey
    std::vector<std::vector<unsigned char>> c_hash_parts = {
        sig.m_message,
        ec_point_to_bytes(params.V_ring_pubkey),
        ec_point_to_bytes(sig.L_link_tag_point),
        ec_point_to_bytes(sig.L1_point),
        ec_point_to_bytes(sig.L2_point),
        ec_point_to_bytes(sig.T1_point),
        gt_elem_to_bytes(sig.Pi1_elem),
        gt_elem_to_bytes(X_c_for_hash)
    };
    bn_t c_from_func = H1_func(c_hash_parts);
    bn_copy(sig.c_scalar, c_from_func);
    bn_free(c_from_func);
    gt_free(X_c_for_hash);


    // s_i scalars
    // s1 = k1 + c*r1
    bn_mul(temp_bn1, sig.c_scalar, r1); bn_mod(temp_bn1, temp_bn1, order);
    bn_add(sig.s_scalars[0], k1, temp_bn1); bn_mod(sig.s_scalars[0], sig.s_scalars[0], order);
    // s2 = k2 + c*r2
    bn_mul(temp_bn1, sig.c_scalar, r2); bn_mod(temp_bn1, temp_bn1, order);
    bn_add(sig.s_scalars[1], k2, temp_bn1); bn_mod(sig.s_scalars[1], sig.s_scalars[1], order);
    // s3 = k3 + c*r3
    bn_mul(temp_bn1, sig.c_scalar, r3); bn_mod(temp_bn1, temp_bn1, order);
    bn_add(sig.s_scalars[2], k3, temp_bn1); bn_mod(sig.s_ scalars[2], sig.s_scalars[2], order);
    // s4 = k4 + c*h_id_i
    bn_mul(temp_bn1, sig.c_scalar, usk.h_id_scalar); bn_mod(temp_bn1, temp_bn1, order);
    bn_add(sig.s_scalars[3], k4, temp_bn1); bn_mod(sig.s_scalars[3], sig.s_scalars[3], order);
    // s5 = k5 + c*r2*h_id_i
    bn_mul(temp_bn1, r2, usk.h_id_scalar); bn_mod(temp_bn1, temp_bn1, order);
    bn_mul(temp_bn2, sig.c_scalar, temp_bn1); bn_mod(temp_bn2, temp_bn2, order);
    bn_add(sig.s_scalars[4], k5, temp_bn2); bn_mod(sig.s_scalars[4], sig.s_scalars[4], order);
    // s6 = k6 + c*r3*h_id_i
    bn_mul(temp_bn1, r3, usk.h_id_scalar); bn_mod(temp_bn1, temp_bn1, order);
    bn_mul(temp_bn2, sig.c_scalar, temp_bn1); bn_mod(temp_bn2, temp_bn2, order);
    bn_add(sig.s_scalars[5], k6, temp_bn2); bn_mod(sig.s_scalars[5], sig.s_scalars[5], order);
    // s7 = k7 + c*h_id_i
    bn_mul(temp_bn1, sig.c_scalar, usk.h_id_scalar); bn_mod(temp_bn1, temp_bn1, order);
    bn_add(sig.s_scalars[6], k7, temp_bn1); bn_mod(sig.s_scalars[6], sig.s_scalars[6], order);


    // T2 = (k1 + c*r1 - c)G1_const + k2*G2_const + k3*K_const
    // (k1+cr1) is s1. So (s1-c)G1_const + k2*G2_const + k3*K_const
    bn_sub(temp_bn1, sig.s_scalars[0], sig.c_scalar); bn_mod(temp_bn1, temp_bn1, order); // s1-c
    ec_mul(temp_ec1, params.G1_const, temp_bn1); // (s1-c)G1

    ec_t k2G2, k3K;
    ec_null(k2G2); ec_new(k2G2); ec_null(k3K); ec_new(k3K);
    ec_mul(k2G2, params.G2_const, k2);
    ec_mul(k3K, params.K_const, k3);
    ec_add(sig.T2_point, temp_ec1, k2G2);
    ec_add(sig.T2_point, sig.T2_point, k3K);
    ec_free(k2G2); ec_free(k3K);


    // Π2 = e(P, U2)^(-k7) * e(P, K_const)^(k6) * e(P_pub, K_const)^(k2) * e((L+P_pub), W)^(-c)
    // W is usk.W_point. L+P_pub was computed for Π1.
    // Recompute L_plus_Ppub if not available, or pass it.
    ec_t L_plus_Ppub_for_Pi2; ec_null(L_plus_Ppub_for_Pi2); ec_new(L_plus_Ppub_for_Pi2);
    ec_add(L_plus_Ppub_for_Pi2, sig.L_link_tag_point, params.P_pub);

    gt_t pi2_t1, pi2_t2, pi2_t3, pi2_t4;
    gt_null(pi2_t1); gt_new(pi2_t1); gt_null(pi2_t2); gt_new(pi2_t2);
    gt_null(pi2_t3); gt_new(pi2_t3); gt_null(pi2_t4); gt_new(pi2_t4);
    bn_t neg_k7, neg_c;
    bn_null(neg_k7); bn_new(neg_k7); bn_null(neg_c); bn_new(neg_c);

    bn_neg(neg_k7, k7);
    bn_neg(neg_c, sig.c_scalar);

    pc_map_exp(pi2_t1, params.P, sig.U2_point, neg_k7);            // e(P,U2)^(-k7)
    pc_map_exp(pi2_t2, params.P, params.K_const, k6);              // e(P,K)^(k6)
    pc_map_exp(pi2_t3, params.P_pub, params.K_const, k2);          // e(P_pub,K)^(k2)
    pc_map_exp(pi2_t4, L_plus_Ppub_for_Pi2, usk.W_point, neg_c); // e((L+P_pub),W)^(-c)

    gt_mul(sig.Pi2_elem, pi2_t1, pi2_t2);
    gt_mul(sig.Pi2_elem, sig.Pi2_elem, pi2_t3);
    gt_mul(sig.Pi2_elem, sig.Pi2_elem, pi2_t4);

    gt_free(pi2_t1); gt_free(pi2_t2); gt_free(pi2_t3); gt_free(pi2_t4);
    bn_free(neg_k7); bn_free(neg_c);
    ec_free(L_plus_Ppub_for_Pi2);


    // Cleanup
    ec_free(temp_ec1);
    bn_free(r1); bn_free(r2); bn_free(r3);
    bn_free(k1); bn_free(k2); bn_free(k3); bn_free(k4); bn_free(k5); bn_free(k6); bn_free(k7);
    bn_free(a1); bn_free(a2);
    bn_free(order);
    bn_free(temp_bn1); bn_free(temp_bn2); bn_free(temp_bn3);

    return sig;
}

// 2.2.6 Verification Algorithm (VER-BP)
bool ver_bp(const SLRS_SystemParameters& params, const SLRS_Signature& sig) {
    // Check T1 = s4*G1_const + s5*G2_const + s6*K_const - s7*R
    ec_t s4G1, s5G2, s6K, s7R, T1_check_rhs;
    ec_null(s4G1); ec_new(s4G1); ec_null(s5G2); ec_new(s5G2);
    ec_null(s6K); ec_new(s6K); ec_null(s7R); ec_new(s7R);
    ec_null(T1_check_rhs); ec_new(T1_check_rhs);

    ec_mul(s4G1, params.G1_const, sig.s_scalars[3]); // s4
    ec_mul(s5G2, params.G2_const, sig.s_scalars[4]); // s5
    ec_mul(s6K, params.K_const, sig.s_scalars[5]);   // s6
    ec_mul(s7R, sig.R_point, sig.s_scalars[6]);       // s7

    ec_add(T1_check_rhs, s4G1, s5G2);
    ec_add(T1_check_rhs, T1_check_rhs, s6K);
    ec_sub(T1_check_rhs, T1_check_rhs, s7R);

    bool t1_ok = ec_cmp(sig.T1_point, T1_check_rhs) == RLC_EQ;
    ec_free(s4G1); ec_free(s5G2); ec_free(s6K); ec_free(s7R); ec_free(T1_check_rhs);
    if (!t1_ok) { /* std::cout << "T1 check failed" << std::endl; */ return false; }

    // Check T2 = s1*G1_const + s2*G2_const + s3*K_const - c*R
    ec_t s1G1, s2G2, s3K, cR, T2_check_rhs;
    ec_null(s1G1); ec_new(s1G1); ec_null(s2G2); ec_new(s2G2);
    ec_null(s3K); ec_new(s3K); ec_null(cR); ec_new(cR);
    ec_null(T2_check_rhs); ec_new(T2_check_rhs);

    ec_mul(s1G1, params.G1_const, sig.s_scalars[0]); // s1
    ec_mul(s2G2, params.G2_const, sig.s_scalars[1]); // s2
    ec_mul(s3K, params.K_const, sig.s_scalars[2]);   // s3
    ec_mul(cR, sig.R_point, sig.c_scalar);

    ec_add(T2_check_rhs, s1G1, s2G2);
    ec_add(T2_check_rhs, T2_check_rhs, s3K);
    ec_sub(T2_check_rhs, T2_check_rhs, cR);

    bool t2_ok = ec_cmp(sig.T2_point, T2_check_rhs) == RLC_EQ;
    ec_free(s1G1); ec_free(s2G2); ec_free(s3K); ec_free(cR); ec_free(T2_check_rhs);
    if (!t2_ok) { /* std::cout << "T2 check failed" << std::endl; */ return false; }

    // Check Π1 = e(Q,U1)^(-s7) * e(L2,K)^(s4) * e(Q_pub,K)^(s1) * e(Q,Q)^c * e(Q_pub,U1)^(-c) * e(P,V)
    // V is params.V_ring_pubkey. Q is params.Q_const.
    gt_t pi1_v_t1, pi1_v_t2, pi1_v_t3, pi1_v_t4, pi1_v_t5, pi1_v_t6, Pi1_check_rhs;
    gt_null(pi1_v_t1); gt_new(pi1_v_t1); gt_null(pi1_v_t2); gt_new(pi1_v_t2);
    gt_null(pi1_v_t3); gt_new(pi1_v_t3); gt_null(pi1_v_t4); gt_new(pi1_v_t4);
    gt_null(pi1_v_t5); gt_new(pi1_v_t5); gt_null(pi1_v_t6); gt_new(pi1_v_t6);
    gt_null(Pi1_check_rhs); gt_new(Pi1_check_rhs);
    bn_t neg_s7, neg_c_pi1;
    bn_null(neg_s7); bn_new(neg_s7); bn_null(neg_c_pi1); bn_new(neg_c_pi1);

    bn_neg(neg_s7, sig.s_scalars[6]); // -s7
    bn_neg(neg_c_pi1, sig.c_scalar);  // -c

    pc_map_exp(pi1_v_t1, params.Q_const, sig.U1_point, neg_s7);               // e(Q,U1)^(-s7)
    pc_map_exp(pi1_v_t2, sig.L2_point, params.K_const, sig.s_scalars[3]);     // e(L2,K)^(s4)
    pc_map_exp(pi1_v_t3, params.Q_pub, params.K_const, sig.s_scalars[0]);     // e(Q_pub,K)^(s1)
    pc_map_exp(pi1_v_t4, params.Q_const, params.Q_const, sig.c_scalar);       // e(Q,Q)^c
    pc_map_exp(pi1_v_t5, params.Q_pub, sig.U1_point, neg_c_pi1);              // e(Q_pub,U1)^(-c)
    pc_map(pi1_v_t6, params.P, params.V_ring_pubkey);                         // e(P,V)

    gt_mul(Pi1_check_rhs, pi1_v_t1, pi1_v_t2);
    gt_mul(Pi1_check_rhs, Pi1_check_rhs, pi1_v_t3);
    gt_mul(Pi1_check_rhs, Pi1_check_rhs, pi1_v_t4);
    gt_mul(Pi1_check_rhs, Pi1_check_rhs, pi1_v_t5);
    gt_mul(Pi1_check_rhs, Pi1_check_rhs, pi1_v_t6);

    bool pi1_ok = gt_cmp(sig.Pi1_elem, Pi1_check_rhs) == RLC_EQ;
    gt_free(pi1_v_t1); gt_free(pi1_v_t2); gt_free(pi1_v_t3); gt_free(pi1_v_t4);
    gt_free(pi1_v_t5); gt_free(pi1_v_t6); gt_free(Pi1_check_rhs);
    bn_free(neg_s7); bn_free(neg_c_pi1);
    if (!pi1_ok) { /* std::cout << "Π1 check failed" << std::endl; */ return false; }


    // Check Π2 = e(P,U2)^(-s7) * e(P,K)^(s6) * e(P_pub,K)^(s2) * e(P_pub,U2)^(-c)
    gt_t pi2_v_t1, pi2_v_t2, pi2_v_t3, pi2_v_t4, Pi2_check_rhs;
    gt_null(pi2_v_t1); gt_new(pi2_v_t1); gt_null(pi2_v_t2); gt_new(pi2_v_t2);
    gt_null(pi2_v_t3); gt_new(pi2_v_t3); gt_null(pi2_v_t4); gt_new(pi2_v_t4);
    gt_null(Pi2_check_rhs); gt_new(Pi2_check_rhs);
    bn_t neg_s7_pi2, neg_c_pi2; // Re-declare to avoid scope issues if any, or reuse
    bn_null(neg_s7_pi2); bn_new(neg_s7_pi2); bn_null(neg_c_pi2); bn_new(neg_c_pi2);

    bn_neg(neg_s7_pi2, sig.s_scalars[6]); // -s7
    bn_neg(neg_c_pi2, sig.c_scalar);      // -c

    pc_map_exp(pi2_v_t1, params.P, sig.U2_point, neg_s7_pi2);                 // e(P,U2)^(-s7)
    pc_map_exp(pi2_v_t2, params.P, params.K_const, sig.s_scalars[5]);         // e(P,K)^(s6)
    pc_map_exp(pi2_v_t3, params.P_pub, params.K_const, sig.s_scalars[1]);     // e(P_pub,K)^(s2)
    pc_map_exp(pi2_v_t4, params.P_pub, sig.U2_point, neg_c_pi2);              // e(P_pub,U2)^(-c)

    gt_mul(Pi2_check_rhs, pi2_v_t1, pi2_v_t2);
    gt_mul(Pi2_check_rhs, Pi2_check_rhs, pi2_v_t3);
    gt_mul(Pi2_check_rhs, Pi2_check_rhs, pi2_v_t4);

    bool pi2_ok = gt_cmp(sig.Pi2_elem, Pi2_check_rhs) == RLC_EQ;
    gt_free(pi2_v_t1); gt_free(pi2_v_t2); gt_free(pi2_v_t3); gt_free(pi2_v_t4);
    gt_free(Pi2_check_rhs);
    bn_free(neg_s7_pi2); bn_free(neg_c_pi2);
     if (!pi2_ok) { /* std::cout << "Π2 check failed" << std::endl; */ return false; }

    return true; // All checks passed
}


// 2.2.7 Linking Algorithm (LINK-BP)
bool link_bp(const SLRS_Signature& sig1, const SLRS_Signature& sig2) {
    return ec_cmp(sig1.L_link_tag_point, sig2.L_link_tag_point) == RLC_EQ;
}

#endif // _CSLRS_H